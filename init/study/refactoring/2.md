---
description: 리팩터링 원칙
---

# 2장

### 1월 25일

* 2.1 리팩터링 정의
  * 명사: 소프트웨어의 겉보기는 그대로 유지한채 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
  * 동사: 소프트웨어의 겉보기는 그대로 유지한채 코드 여러가지 리팩터링 기법을 적용하여 소프트웨어를 재구성한다
* 2.2 두개의 모자
  * 리팩터링 모자
    * 기능추가 하지않고, 테스트 케이스도 추가 하지않고(단 발견하지 못한 테스트가 없다는 전제하에) 코드 재구성에만 전념
    * 기능 추가 모자
      * 기존 코드는 건드리지않고 오로지 새 기능에 대한 코드만 추가한다.
* 2.3 리팩터링 하는 이유
  * 리팩터링하면 소프트웨어 설계가 좋아진다
  * 리팩터링하면 소프트웨어를 이해하기 쉬워진다
  * 리팩터링하면 버그를 쉽게 찾을 수 있다
  * 리팩터링하면 프로그래밍 속도를 높일 수 있다
    * 설계 지구력 가설 - [https://martinfowler.com/bliki/DesignStaminaHypothesis.html](https://martinfowler.com/bliki/DesignStaminaHypothesis.html)
* 2.4 언제 리팩터링해야 할까?
  * 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
    * 함수 매개변수화하기(11.2절 - Parameterized Function)
    * [https://martinfowler.com/articles/preparatory-refactoring-example.html](https://martinfowler.com/articles/preparatory-refactoring-example.html)
  * 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
  * 쓰레기 줍기 리팩터링
  * 계획된 리팩터링과 수시로 하는 리팩터링
  * 오래걸리는 리팩터링
  * 코드 리뷰에 리팩터링 활용하기
  * 리팩터링하지 말아야 할 때
    * 지저분한 코드여도 굳이 수정할 필요 없다면 리팩터링 하지 않는다
    * 내부 동작을 이해해야 할 시점에 리팩터링을 해야 효과가 좋다
* 2.5 리팩터링 시 고려할 문제
  * 새 기능 개발 속도 저하
    * 리팩터링의 궁극적인 목적은 개발 속도를 높여서 더 적은 노력으로 더 많은 가치를 창출하는 것
    * **리팩터링을 할지말지에 대한 명확한 기준이 필요함(다음은 저자의 경험)**
      * 새 기능을 넣기 편히지겠네? → 리팩터링함
      * 그리 불편하지도 않고, 코드를 내가 직접 건드릴 일이 없어 → 리팩터링 안함
      * 어떻게 개선해야할지 모르겠어 → 리팩터링 안함
    * 리팩터링을 클린코드, 바람직한 엔지니어링 습관(개발자 가스라이팅) 처럼 도덕적인 이유로 정당화 해선 안된다
      * 오로지 경제적인 이유로만 리팩터링을 진행하자
        * 개발기간의 단축 → 기능 추가 시간 단축, 버그 수정 시간 단축
  * 코드 소유권
    * 코드 소유권이 나뉘어져 있으면 리팩터링에 방해가됨
      * 함수를 호출하는 부분이 내 소유가 아니면 함수명을 바꿨을때에 호출부를 변경할 수 없는 경우
  * 브랜치
    * 머지와 통합을 명확히 구분함
      * 머지
        * 마스터 브랜치를 내 브랜치로 머지한다
        * 마스터 브랜치의 내용은 변하지 않고 내 브랜치의 내용만 바뀐다 → **내 브랜치 내용만 바뀌기 때문에 단방향**
      * 병합
        * 마스터 브랜치를 개인 브랜치로 가져와서(pull) 작업한 결과를 다시 마스터에 올린다(push)
        * 마스터 브랜치의 내용을 내 브랜치에 합치고, 내 브랜치 내용을 다시 마스터 브랜치에 올린다 → **내 브랜치의 내용도 바뀌고 마스터 브랜치의 내용도 바뀌기 때문에 양방향**
    * 브랜치 통합의 주기는 짧게 가져가자(지속적 통합-CI, 트렁크 기반 개발 - TBD)
      * 익스트림 프로그래밍(XP)
  * 테스팅
    * 리팩터링의 핵심 중 하나는 기존 코드의 동작은 똑같이 유지되는 것임
    * 리팩터링 하다가 실수해서 기존의 동작이 깨지는 것을 방지하기 위해 테스트 스위트가 필요함
      * 테스트 스위트는 수시로 실행할 수 있어야 하고 빠르게 실행되어야함
      * 즉 자가 테스트 코드가 필요함 - [https://martinfowler.com/bliki/SelfTestingCode.html](https://martinfowler.com/bliki/SelfTestingCode.html)
  * 레거시 코드
    * 테스트 코드가 없는 거대한 레거시 코드
    * [레거시 코드 활용 전략](https://product.kyobobook.co.kr/detail/S000001804724)
  * 데이터베이스
* 2.6 리팩터링, 아키텍처, 애그니(YAGNI)
  * 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다
  * 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링 한다
  * 예상되는 변경을 미리 반영하는 리팩터링을 미루면 나중에 얼마나 어려워질지를 가늠해보면 판단에 도움이 된다
    * 힘들어 진다는 확신이 들 때만 유연성 매커니즘을 추가한다(가령 이 함수가 범용적으로 쓰인다던지 하는 생각)
* 2.7 리팩터링과 소프트웨어 개발 프로세스
  * 테스트 주도 개발(TDD) = 자가 테스트 코드 + 리팩터링
  * 팀원과 개발하면서 리팩터링을 하려면 지속적 통합을 적극 권장한다
    * 그 이유는 팀원 각자가 적용한 리팩터링 결과를 빠르게 동료와 공유할 수 있기 때문이다
* 2.8 리팩터링과 성능
  * 직관적인 설계 vs 성능
    * 리팩터링을 진행하면 성능이 안좋아 질 수 있는건 사실임 하지만 **성능을 튜닝하기에는 쉬워짐**
    * 먼저 튜닝하기 쉽게 만들고 그 후에 원하는 속도가 나게끔 튜닝하는 것
  * 소프트웨어를 작성하는 방법 3가지
    * 시간 예산 분배방식
      * 설계를 여러 컴포넌트로 나누고 컴포넌트마다 자원(시간과 공간) 예산을 할당
    * 끊임없이 관심을 기울이는 방식
      * 전체 코드 중 극히 일부에서 대부분의 시간(성능)을 소비함
      * 그래서 코드 전체를 고르게 최적화한다면 그 중 90퍼센트는 효과가 거의 없기 때문에 시간낭비인 셈
    * 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는 데에만 집중하는 방식
* 2.9 리팩터링의 유래
  * [리팩터링에 대한 최초의 연구](http://www.laputan.org/pub/papers/opdyke-thesis.pdf)
* 2.10 리팩터링 자동화
