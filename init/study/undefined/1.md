---
description: 프로그래밍 패러다임과 객체, 설계
---

# 1장

## 들어가며 - 프로그래밍 패러다임

### 패러다임의 시대

* 과학의 관점
  * 우주를 바라보는 관점이 천동설에서 지동설오 변화한 사건은 패러다임 전환의 가장 대표적인 예
  * 프로그래밍의 관점
    * 프로그래밍에서는 절차지향에서 객체지향의 변화를 얘기함

### 프로그래밍 패러다임

* 특정 시대의 어느 성숙한 개발자 공동체에 의해 수용된 프로그래밍 방법과 문제 해결 방법, 프로그래밍 스타일이라고 할 수 있다.
  * 이 패러다임에 따라, 우리가 해결할 문제를 바라보는 방식과 프로그램을 작성하는 방법이 달라진다.
* 프로그래밍 언어가 제공하는 특징과 프로그래밍 스타일은 해당 언어가 채택하는 프로그래밍 패러다임에 따라 달라진다.
* 과학과의 차이점
  * 서로 다른 패러다임이 공존 할 수 없음 ↔ 서로 다른 패러다임이 공존 할 수 있다. 공존함으로써 서로의 장단점을 보완하는 경향을 보인다.
  * 서로 다른 패러다임은 서로 비교 할 수 없으며 같은 대상에 대해 서로 다른 것을 본다. ↔ 절차형 패러다임, 객체지향 패러다임을 비교 하는 것이 가능하다. 또한 절차형 패러다임의 기반 위에서 객체지향 패러다임이 탄생하였다. 때문에 패러다임이 절차형에서 객체지향으로 넘어간다고 해서 바라보는 세상이 완전히 달라지는 것은 아니다.
  * 혁명적 ↔ 발전적

***

## 객체, 설계

### 소프트웨어 모듈이 가져야 하는 3가지 기능

> [_로버트 마틴 - 클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천 방법_](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=108856171\&srsltid=AfmBOopTt2bb3Rg_p2n90r8a1siS30-ZVm3DPPAJ2v2wT3o-MJyFrTjf)

{% hint style="info" %}
_여기서 말하는 모듈은 클래스나 패키지, 라이브러리와 같은 프로그램을 구성하는 임의의 요소를 말한다_
{% endhint %}

1. 제대로 동작해야한다.
2. 모듈은 변경을 위해 존재한다 → 변경 용이
3. 코드를 읽는 사람과 의사소통 하는 것이다 → 이해하기 쉬워야함

### 변경에 취약한 코드

어떤 한 객체가 세부사항을 많이 알면 알 수록 **의존성(dependency)**&#xC5D0; 대해 문제가 발생한다. 의존성은 변경에 대한 영향을 암시하는데, 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체들도 함께 변경될 수 있다는 사실이 내포돼 있다. **객체지향 설계에서는 의존성을 완벽히 제거하는 것이 아닌** 기능을 구현하는데에 있어서 **최소한의 의존성만 유지하고 불필요한 의존성은 제거**하는데 목표를 둔다.

객체 사이의 의존성이 과한 경우를 **결합도(coupling)**&#xAC00; 높다고 말한다. 반대로 객체들이 합리적인 수준으로 의존할 경우에는 결합도가 낮다고 말한다. 결합도는 의존성과 관련돼 있기 때문에 이 역시 변경과 관련이 있다. 때문에 두 객체 사이의 결합도가 높이면 함께 변경될 확률도 높아지기 때문에 변경에 취약한 코드가 만들어 진다.

따라서 목표는 **객체 사이의 결합도를 낮춰(합리적인 수준으로 의존하게) 변경이 용이한 설계**를 만드는 것이다.

### 자율성을 높이자

다른 객체의 내부적인 세부사항을 감추는 것을 **캡슐화(encapsulation)**&#xB77C;고 한다. 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체 사이의 결합도를 낮출 수 있다. 결합도가 낮아지면 설계를 좀 더 쉽게 변경할 수 있다.

### 캡슐화와 응집도

객체 내부의 상태는 캡슐화 하고 객체 간에는 오직 메시지를 통해서만 상호작용 하도록 만드는 것이다. 즉 내부에서 어떻게 처리하는지는 알지 못하지만 원하는 결과를 반환할 것이다라는 사실만 알고 있으면 된다. 관련이 있는 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 **응집도(cohesion)**&#xAC00; 높다고 말한다. 자율적인 객체를 만들면 결합도를 낮출 수 있을 뿐더러 응집도를 높일 수 있다.

응집도를 높이기 위해서는 객체가 스스로 자신의 데이터를 책임져야 한다.

### 객체지향

객체지향 프로그래밍은 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식이다. 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다. 자신의 문제를 내부에서 처리하기 때문에 내부의 변경이 외부에 파급되지 않아서 변경에 용이하다.

### 책임

절차지향과 객체지향의 근본적인 차이는 책임의 이동(Shift of Responsibility)이다. 여기서는 _책&#xC784;_&#xC744; 기능을 가리키는 객체지향 세계의 용어로 생각해도 무방하다. 절차지향에서 책임은 중앙집중되어있지만, 객체지향에서는 책임이 개별 객체로 흩어진다. 즉 스스로 책임을 수행하는 자율적인 객체들이 공동체를 구성함으로써 완성된다.

스스로 책임을 수행하는 관점에서 데이터와 프로세스를 하나의 단위로 통합해 놓는 방식으로 표현하기도 한다. 사실 객체지향의 핵심은 적절한 객체에 적절한 책임을 할당하는 것이다. 객체는 다른 객체와의 협력이라는 문맥안에서 특정한 역할을 수행하는데 필요한 적절한 책임을 수행해야 한다. 따라서 어떤 데이터를 가지기 보다는, 어떤 책임을 할당할 것이냐에 초점을 맞춰야 한다.

### 의인화

현실 세계에서는 수동적인 존재이더라도 객체지향 셰게로 들어오면 모든 것이 능동적이고 자율적인 존재가 된다. 이처럼 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 의인화(anthropomorphism)라고 한다.

### 설계

설계는 코드를 작성하면서 코드를 어떻게 배치할 것인지를 결정하는 과정에서 나온다. 그래서 코드를 작성하지 않고서는 검증할 수 없다. **설계를 어렵게 만드는 것은 의존성과 연관이 있다. 앞에서 말했듯 불필요한 의존성이 많이 생긴다면 결합도가 높아지게 된다. 그래서 불필요한 의존성을 제거함으로써 결합도가 낮춰야 한다. 결합도를 낮추기 위해 캡슐화를 사용하였고 낮아진 결합도에 의해 객체는 자율성이 높아지고 응집도가 높아짐으로써 변경에 용이하고 이해하기 쉬운 코드를 작성할 수 있다.**

어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다. 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물이다. 그래서 어떠한 경우에도 모든 사람을 만족시킬 수 있는 설계를 만들 수는 없다.

그럼 좋은 설계란 무엇일까? 2가지 요구사항을 만족해야 한다.

1. 기능이 동작해야 하고
2. **미래의 변경을 유연하게 받아 들일 수 있어야 한다.**

2번을 중점적으로 보자. 요구사항은 늘 바뀐다. 개발을 시작하는 시점(폭포수에서는 설계단계)에 모든 요구사항을 수집하는 것은 불가능하다.

{% hint style="info" %}
실무를 하다보면 설계단계에서 캐치하지 못한 새로운 혹은 잊고 있었던 것들이 튀어나와 요구사항이 되기도 한다
{% endhint %}

또한 요구사항이 변경됨에 따라 코드도 필연적으로 변경이 발생한다. 코드가 변경되면 버그가 추가될 가능성이 높아진다.

정리해보면 결국 이런 사이클을 갖는다.

```
1. 요구사항을 초기 단계에 전부 수집할 수 없음
2. 나중에 요구사항이 반영됨
3. 반영된 요구사항을 적용하기 위해 코드를 수정해야함
4. 코드 수정에 의해 버그가 추가될 가능성이 높아짐
5. 버그에 대한 두려움과 불확실성 때문에 코드 수정을 회피하고 싶어짐
```

**그래서 결국에는 변경을 유연하게 대응할 수 있는 코드를 작성해야 한다.**



## 3줄 요약

* 훌륭한 객체지향 설계는 객체 사이의 의존성을 적절히 관리하는 설계다.
* 설계란 코드를 어떻게 배치할 것인지에 대한 결정이다.
* 좋은 설계란 기능이 동작해야하고, 변경에 유연하게 대응하는 것이다. 그렇게 하기 위해선 객체 사이의 불필요한 의존성을 제거해야 한다.
